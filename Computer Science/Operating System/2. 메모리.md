# 3.1 메모리

## **개요**

메모리 계층과 메모리 관리에 대해서 알아봅니다.


## **핵심 용어**

- `TLB`: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시로, CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시키는 캐시 계층
- `페이지 폴트`: 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생하는 현상
- `내부 단편화`: 메모리를 나눈 크기가 프로그램의 크기보다 커서 메모리가 많이 남지만, 다른 프로세스가 사용할 수 없는 현상
- `외부 단편화`: 메모리를 나눈 크기가 프로그램의 크기보다 작아서 프로그램이 들어가지 못하는 공간이 많이 발생하는 현상

<!-- TOC -->

- [메모리](#%EB%A9%94%EB%AA%A8%EB%A6%AC)
    - [**개요**](#%EA%B0%9C%EC%9A%94)
    - [**핵심 용어**](#%ED%95%B5%EC%8B%AC-%EC%9A%A9%EC%96%B4)
    - [**목차**](#%EB%AA%A9%EC%B0%A8)
    - [**메모리 계층**](#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5)
        - [계층구조의 의의](#%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%98%EC%9D%98)
        - [계층구조의 종류](#%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A2%85%EB%A5%98)
            - [레지스터](#%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
            - [캐시](#%EC%BA%90%EC%8B%9C)
            - [메모리RAM](#%EB%A9%94%EB%AA%A8%EB%A6%ACram)
            - [저장장치하드 디스크](#%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%ED%95%98%EB%93%9C-%EB%94%94%EC%8A%A4%ED%81%AC)
        - [메모리 접근](#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A0%91%EA%B7%BC)
            - [캐시히트와 캐시미스](#%EC%BA%90%EC%8B%9C%ED%9E%88%ED%8A%B8%EC%99%80-%EC%BA%90%EC%8B%9C%EB%AF%B8%EC%8A%A4)
            - [캐시 매핑](#%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91)
            - [웹 브라우저의 캐시](#%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%BA%90%EC%8B%9C)
            - [데이터베이스의 캐싱 계층 redis](#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%BA%90%EC%8B%B1-%EA%B3%84%EC%B8%B5-redis)
    - [**메모리 관리**](#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
        - [가상 메모리](#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
        - [페이지 폴트와 스와핑](#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8%EC%99%80-%EC%8A%A4%EC%99%80%ED%95%91)
        - [메모리 관리 전략](#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)
            - [연속 메모리 할당](#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9)
            - [불연속 메모리 할당](#%EB%B6%88%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9)
        - [페이지 교체 알고리즘](#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
            - [오프라인 알고리즘OPT - Optimal](#%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98opt---optimal)
            - [FIFO - First In First Out](#fifo---first-in-first-out)
            - [LRU - Least Recently Used](#lru---least-recently-used)
            - [NUR - Not Used Recently](#nur---not-used-recently)
            - [LFU - Least Frequently Used](#lfu---least-frequently-used)
    - [**참고 자료**](#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C)

<!-- /TOC -->


---

## **메모리 계층**

<img title= "이미지1_메모리 계층" src = "https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Ff9c8088c-0fec-4dad-ac95-ddf3601aa1d4%2F%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0.png">

### 계층구조의 의의

- 경제성
    - 16GB SSD는 16GB RAM 보다 저렴한 가격에 구매 가능하다.
    - 따라서 비싼 하드웨어는 꼭 필요한 만큼의 크기만 사용하고, 저렴한 하드웨어를 넉넉한 크기만큼 사용한다.
- 속도차로 인한 병목현상 해소
    - 캐시 계층을 통해서 빠른 장치와 느린 장치에서 속도 차이에 의한 병목 현상을 줄일 수 있다. 자세한 건 아래의 [캐시](###캐시)에서 알아보자.
-  참조의 지역성
    - 자주 쓰이는 데이터는 계속 자주 쓰이고, 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않는다.
    - 따라서 운영체제·CPU는 자동으로 자주 쓰이거나 쓰일 것 같은 데이터를 메모리에서 캐시로 읽어온다.
    - 자주 쓰이는 데이터는 전체 데이터 양에 비해 작은 양이므로 캐시는 메모리보다, 메모리는 하드디스크보다 더 작아도 된다.


### 계층구조의 종류

#### 레지스터

- 개념
    - CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 휘발성 기억장치이다.
    - 프로세서에 위치한 고속 메모리로, 프로세스가 바로 사용할 수 있는 데이터(소량의 데이터, 처리 중인 중간 결과 등)를 담고 있는 영역이다.
- 특징
    - CPU는 자체적으로 데이터를 저장할 방법이 없으므로 메모리로 직접 데이터를 전송할 수 없고, 연산을 위해서 반드시 레지스터를 거쳐야 한다. 이를 위해 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있다.

#### 캐시

- 개념
    - 데이터나 값을 미리 복사해 임시로 저장하는 휘발성 기억장치이다.
- 특징
    - 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우, 값을 다시 계산하는 시간을 절약하고 싶은 경우 등 시스템의 효율성을 위해 사용한다.
    - 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 병목 현상을 완화하기 위한 범용 메모리
- 구성
    - L1 캐시
        - 일반적으로 CPU 칩안에 내장되어 데이터 사용 및 참조에 가장 먼저 사용되는 캐시 메모리이다.
        - CPU 성능에 직접적인 영향을 끼친다.
    - L2 캐시
        - L1 캐시 메모리와 용도와 역할이 비슷하다.
        - 속도 : L1 캐시 > L2 캐시 > 일반메모리(RAM)
        - CPU 성능에 직접적인 영향을 끼친다.
    - L3 캐시
        - L1 캐시, L2 캐시와 동일한 원리로 작동한다.
        - 대부분 CPU가 아닌 메인보드에 내장되어 있다.
        - CPU 성능에 직접적인 영향을 끼치지 않는다.
- 참조 지역성
    - 개념
        - 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것이다.
        - 캐시를 직접 설정할 때에는 자주 참조하는 데이터를 기반으로 설정하는데, 지역성은 이에 대한 근거가 된다.
        - 참조 지역성은 시간 지역성(temporal locality)와 공간 지역성(spatial locality)으로 나뉜다.
    - 시간 지역성
        - 개념: 최근 사용한 데이터에 다시 접근하려는 특성을 말한다.
        - 예시: for 반복문 안의 변수 i에 대해 반복적으로 접근하는 경우
    - 공간 지역성
        - 개념: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.
        - 예시: 공간을 나타내는 배열의 각 요소들에 연속적인 접근을 하는 경우

#### 메모리(RAM)

- 개념
    - 주기억장치(= 1차 기억 장치)로, 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치이다.
    - 보통 RAM(Random Access Memory을 가리키고, 휘발성 기억장치이다.
- 특징
    - Random Access : 어느 위치에서든 똑같은 속도로 접근하여 읽고 쓸 수 있음을 의미한다.
    - 사용자가 요청하는 프로그램이나 문서를 하드디스크로부터 복사하여 메모리로 임시 저장하고, 필요 시마다 CPU에 **빠르게 전달**한다.
    - 전원이 유지되는 동안 CPU의 연산 및 동작에 필요한 모든 내용이 저장되고, 전원 종료시 내용이 삭제된다.

#### 저장장치(하드 디스크)

- 개념
    - 순차접근이 가능한 컴퓨터의 비휘발성 보조 기억 장치이다.
- 특징
    - 비휘발성 데이터 저장소 가운데 가장 대중적이며 용량 대비 가격이 가장 저렴하다.

### 메모리 접근

####  캐시히트와 캐시미스

- 캐시 히트(Cache Hit)
    - 필요한 데이터가 캐시 메모리에 존재할 때를 나타낸다.
    - 위치가 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르다.
- 캐시 미스(Cache Miss)
    - 필요한 데이터가 캐시 메모리에 없어서 주메모리에서 찾아 캐시 메모리에 로드한다.
    - 시스템 버스 기반으로 작동하기 때문에 느리다.

#### 캐시 매핑

- 캐시 매핑의 의의
    - 캐시매핑이란 캐시가 히트되기 위해 매핑하는 방법을 말한다.
    - CPU의 레지스터와 RAM 간에 데이터를 주고받을 때 둘의 사이즈에 있어 간극이 크기 때문에, 작은 레지스터가 캐시 계층으로써 원활히 작동하기 위해 매핑을 잘 하는 것이 중요하다.
- 캐시 매핑의 종류
    - 직접 매핑
        - 각 메모리 위치가 캐시내에서 정확히 한곳에만 매핑되는 구조이다.
        - 장점 : 구현이 단순하고 접근 속도가 빠르다.
        - 단점 : 매번 교체를 하기 때문에 동일 캐시 블록에 매핑되는 다른 메모리가 번갈아 실행되면 매우 낮은 적중률을 보여준다.(잦은 충돌 발생)
    - 연관 매핑
        - 직접매핑에서는 인덱스가 필요했지만, 완전 연관 사상에서는 빈자리를 찾으면 끝이다. 캐시 블록 번호는 메모리 블록 번호와 무관하고, 메모리 블록의 어떤 정보도 포함하지 않는다.
        - 장점: 직접 연관 사상보다 적중률이 높다.
        - 단점: 속도가 느리고 고가의 메모리가 필요하다.
    - 집합 연관 매핑
        - 직접과 연관을 절충한 방식으로, 직접 사상처럼 메모리 블록은 정해진 인덱스만 들어갈 수 있지만 블록이 여러개의 집합으로 이루어져서 그 집합 내에 아무 자리만 들어가면 되는 방식이다.
        - 장점: 저렴하고 속도가 높다.
    - 적중률: 직접 < 집합 연관 < 완전

#### 웹 브라우저의 캐시
- 사용 의의
    - 사용자의 커스텀 정보나 인증 모듈 관련 사항을 웹 브라우저에 저장하고, 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지에 쓰인다.
- 종류
    - 쿠키
        - 만료기한이 있는 키-값 저장소이다.
        - 4KB까지 데이터 저장이 가능하다.
        - 만료기한을 정할 수 있고, 보통 서버에서 이를 정한다.
    - 로컬 스토리지
        - 만료기한이 없는 키-값 저장소이다.
        - 5KB까지 데이터 저장이 가능하며 웹 브라우저를 닫아도 유지된다.
        - HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없고, 클라이언트에서만 수정 가능하다.
    - 세션 스토리지
        - 만료기한이 없는 키-값 저장소이다.
        - 5KB까지 데이터 저장이 가능하며 탭 단위로 세션 스토리지를 생성하고, 탭을 닫을 때 해당 데이터가 삭제된다.
        - HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없고, 클라이언트에서만 수정 가능하다.

#### 데이터베이스의 캐싱 계층 redis

- 데이터베이스 시스템 구축 시, 메인 데이터베이스 위에 레디스(redis) 데이터베이스 계층을 '캐싱 계층'으로 둬서 성능을 향상시키기도 한다.
- Redis
    - 개념
        - 원격에 위치하고 프로세스로 존제하는 키-값 저장소이다.
    - 특징
        - 관계형 데이터베이스와 달리 쿼리 연산을 지원하지 않지만, **데이터의 고속 읽기와 쓰기에 최적화**되어 있다.
        - 메모리 기반이지만 영속적인 데이터 보존이 가능하다.
        - 기본적으로 1개의 싱글 쓰레드로 수행되기 때문에, 안정적은 인프라를 구축하기위해서는 [Replication(Master-Slave 구조)](http://redisgate.kr/redis/configuration/replication.php)이 필수이다.

---

## **메모리 관리**

### 가상 메모리

- 개념
    - 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만든다.
- 특징
    - 가상적으로 주어지는 가상 주소와 실제 메모리상에 있는 실제 주소에 있어서, 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환된다. 따라서 사용자는 실제 주소를 의식할 필요 없이 프로그램 구축이 가능하다.
    - 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리된다. 이 때 속도 향상을 위해 `TLB`를 사용한다.

### 페이지 폴트와 스와핑

- 스와핑 개념
    - `페이지 폴트`가 발생했을 때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것
- 스와핑
- 페이지 폴트 과정
    1. 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 없을 때, 메모리 관리 장치(MMU)가 trap을 발생시켜 운영체제에 알린다.
    2. 운영체제는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.
    3. 해당 프레임을 실제 메모리에 가져와서 [페이지 교체 알고리즘](###페이지-교체-알고리즘)을 기반으로 특정 페이지와 교체한다.(이 때 스와핑 발생)
    4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작한다.
- 스레싱
    - 개념
        - 메모리에 너무 많은 프로세스가 동시에 올라가게 될 때 스와핑이 일어나서 발생하는 현상이다.
        - 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능 저하를 초래한다.
    - 스레싱이 일어나는 과정
        - 페이지 폴트가 일어나면 CPU 이용률이 낮아진다.
        - CPU 이용률이 낮아지면 운영체제는 CPU가 한가하다는 판단으로 가용성 증대를 위해 더 많은 프로세스를 메모리에 올린다.
        - 악순환이 반복되며 스레싱이 발생한다.
    - 하드웨어적인 해결책
        - 메모리 증대시키기
        - HDD의 사용을 SDD로 바꾸기
    - 운영체제의 해결책
        - 작업 세트(working set): 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하고, 이를 통해 탐색에 드는 비용과 스와핑을 감소시킨다.
        - PFF(Page Fault Frequency): 페이지 폴트 빈도를 조절하기 위해 상한선 도달 시 프레임 증가, 하한선 도달 시 프레임 감소를 유도한다.

### 메모리 관리 전략

#### 연속 메모리 할당

- 개념
    - 프로세스를 메모리에 연속적으로 할당하는 기법이다.
    - 고정 분할 방식과 가변 분할 방식이 있다.
- 고정 분할 방식
    - 메모리를 미리 나누어 관리하는 방식이다.
    - 융통성이 없고, `내부 단편화`가 발생한다.
- 가변 분할 방식
    - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다.
    - 내부 단편화는 발생하지 않지만 `외부 단편화`가 발생할 수 있다.
    - 할당 방식의 종류
        - 최초 적합(First fit): 가장 처음 만나는 빈 메모리 공간에 프로세스를 할당하는 방식
        - 최적 적합(Best fit): 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당한다.
        - 최악 적합(Worst fit): 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당한다.

#### 불연속 메모리 할당

- 개념
    - 프로세스를 메모리에 연속적으로 할당하지 않으며, 현대 운영체제가 쓰는 방법이다.
- 종류
    - 페이징(Paging)
        - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 방식이다.
        - MMU(Memory Management Unit)의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 만든다.
        - 장점: 홀의 크기가 균일하지 않은 문제가 사라진다.
        - 단점: 내부 단편화가 발생하고, 주소 변환이 복잡해진다.
    - 세그멘테이션(Segmentation)
        - 페이징 기법과 반대로 서로 다른 크기의 논리적 단위인 세그먼트로 분할하는 방식이다.
        - 장점: 공유와 보안 측면에서 뛰어나다.
        - 단점: 홀 크기가 균일하지 않고 외부 단편화가 발생한다.
    - 페이지드 세그멘테이션
        - 페이징과 세그멘테이션을 혼용하여 단편화를 최대한 줄이는 전략이다.
        - 장점: 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나눈다.

### 페이지 교체 알고리즘

#### 오프라인 알고리즘(OPT - Optimal)

- 개념
    - 앞으로 가장 오랫동안 사용되지 않을 페이지와 현재 할당하는 페이지를 교체하는 알고리즘이다.
    - 가장 이상적이지만, 프로세스가 앞으로 사용할 페이지를 미리 알아야 하는데 이는 불가능하므로, 비교 연구 목적을 위해 사용된다.

#### FIFO - First In First Out

- 개념
    - 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 알고리즘이다.

#### LRU - Least Recently Used

- 개념
    - 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘이다.
- 특징
    - 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이라는 가정을 한다.
    - 사용된 시간을 알수있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거한다.
    - 큐로 구현가능하다. 사용한 데이터를 큐에서 제거하여 맨 위로다시 올리고, **프레임이 모자랄 경우 맨 아래에 있는 데이터를 삭제**한다.
- 단점
    - 오랫동안 참조하지 않았음을 파악하기 위해 각 페이지마다 카운터나 큐, 스택과 같은 별도의 하드웨어가 필요하다.
    - 프로세스가 주기억장치에 접근할때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생한다.

#### NUR - Not Used Recently

- 개념
    - 최근에 사용하지 않은 페이지를 교체하는 알고리즘으로 클락(clock) 알고리즘이라고도 한다.
- 특징
    - 0과 1을 가진 비트를 두고 시계 방향으로 돌면서 0을 찾으면 해당 프로세스를 교체 후 1로 바꾼다.
    - 1은 최근에 참조되었음을, 0은 참조되지 않았음을 의미한다.

#### LFU - Least Frequently Used

- 개념
    - 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘이다.
- 특징
    - LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조횟수를 통해 장기적 시간규모에서의 참조성향을 고려할 수 있다.
- 단점
    - 가장 최근에 불러온 페이지가 교체될 수 있다.
    - 구현이 복잡하고 막대한 오버헤드가 발생한다.

---

## **참고 자료**

- 관련 서적
    - [면접을 위한 CS 전공지식 노트(주홍철)](https://product.kyobobook.co.kr/detail/S000001834833?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=aud-901091942354:dsa-435935280379&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1&gclid=Cj0KCQjwwYSwBhDcARIsAOyL0fhby9LTtW8HLZ5Wg0aW9oKf_EyHPNtAttNCtkeyvmU4HlWw4sGx6VYaAnT5EALw_wcB)
- 이미지 출처
    - [이미지1_메모리 계층](https://velog.io/@yu-jin-song/CS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0)
- 블로그
    - [메모리 계층구조별 특징](https://velog.io/@yu-jin-song/CS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0)
    - [redis 소개 및 사용처](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EA%B0%9C%EB%85%90-%EC%86%8C%EA%B0%9C-%EC%82%AC%EC%9A%A9%EC%B2%98-%EC%BA%90%EC%8B%9C-%EC%84%B8%EC%85%98-%ED%95%9C%EB%88%88%EC%97%90-%EC%8F%99-%EC%A0%95%EB%A6%AC?category=918728#redis-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0---%EC%BA%90%EC%8B%9Ccache)
    - [메모리 관리 전략](https://velog.io/@jisoolee11/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
    - [페이지 교체 알고리즘](https://doh-an.tistory.com/28)
- 깃허브
    - []()
