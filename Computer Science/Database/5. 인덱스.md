# 4.5 인덱스

## **개요**
인덱스의 예시와 만드는 방법에 대해 알아봅니다.

## **목차**

<!-- TOC -->

- [인덱스](#%EC%9D%B8%EB%8D%B1%EC%8A%A4)
    - [**개요**](#%EA%B0%9C%EC%9A%94)
    - [**목차**](#%EB%AA%A9%EC%B0%A8)
    - [인덱스](#%EC%9D%B8%EB%8D%B1%EC%8A%A4)
    - [B-트리](#b-%ED%8A%B8%EB%A6%AC)
    - [인덱스 만드는 방법](#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95)
        - [MySQL](#mysql)
        - [MongoDB](#mongodb)
    - [인덱스 최적화 기법](#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B2%95)
        - [MongoDB 최적화 기법의 특징 3가지](#mongodb-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B2%95%EC%9D%98-%ED%8A%B9%EC%A7%95-3%EA%B0%80%EC%A7%80)
    - [**참고 자료**](#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C)

<!-- /TOC -->

---

## 인덱스

- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치로, B-트리 자료 구조로 이루어져 있다.
- 인덱스를 설정하면 테이블 안에서 찾고자 하는 데이터를 빠르고 쉽게 찾을 수 있다.

## B-트리

- 구조
    - B-트리는 루트 노드와 리프 노드, 그리고 그 사이에 있는 브랜치 노드로 나뉜다.

- 예제 1

    <img alt="B-트리 예제1" width=400 src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvI2Ad%2Fbtr0IGfUtb8%2FaagkCkfZtBqjBcUhRYFmW0%2Fimg.jpg">

    - 만약 E를 찾는다고 하면, 전체 테이블을 탐색하는 것이 아니라 E가 있을 법한 리프 노드로 들어가서 탐색한다.
        - 위 그림처럼 E는 D와 L 사이에 있으므로, 루트 노드에서 D로 들어가고 리프 노드에서 E를 찾을 수 있다.
    - 자료 구조 없이 탐색한다면 다섯 번을 탐색해야 하지만, 이렇게 노드로 나누면 두 번만에 값을 찾을 수 있다.

- 예제 2

    <img alt="B-트리 예제2" width=400 src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMTZe6%2Fbtr0BX4nini%2FgpJfAlAU123udiEPMCgLs0%2Fimg.jpg">

    - 트리 탐색은 루트 노드부터 일어나서 브랜치 노드를 거쳐 리프 노드까지 내려온다.
    - 57을 찾는다고 할 때, '57보다 같거나 클 때까지'를 기반으로 탐색이 일어난다.
        - 처음 루트 노드에서는 39,83 을 탐색한다.
        - 이후 아래 노드로 내려와 46,53,57 등 정렬된 값을 기반으로 탐색한다.
        - 마지막 리프 노드에서 57을 찾고, 이것이 가리키는 데이터 포인터를 통해 결괏값을 반환한다.

- 인덱스가 효율적인 이유
    - 균형 잡힌 트리 구조와 트리 깊이의 **대수확장성** 덕분이다.
        > **대수확장성**: 트리 깊이가 리프 노드 수에 비해 매우 느리게 커지는 것이다.

## 인덱스 만드는 방법

### MySQL

- 클러스터형 인덱스

    <img alt="클러스터형 인덱스" width=400 src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fctfsmx%2Fbtr5gtxbwfN%2F2Qvu0dGgtpFUf5kP3Nd3y0%2Fimg.png">

    - 개념
        - 인덱스 자체에 데이터가 저장되어 있다.
    - 특징
        - 클러스터형 인덱스는 테이블당 하나를 설정할 수 있다.
        - primary key 옵션을 이용해 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스를 만들 수 있다.

- 세컨더리 인덱스

    <img alt="세컨더리 인덱스" width=400 src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcGeVhr%2Fbtr5ozpNkut%2FHmvO4kGoV8PsccV9GVL5C0%2Fimg.png">

    - 개념
        - 인덱스 자체에 데이터가 저장되지 않고 데이터의 주소가 저장되어 있다.
    - 특징
        - 세컨더리 인덱스는 create index... 명령어를 기반으로 만들 수 있다.

- 비교
    - 클러스터형 인덱스는 하나의 인덱스만 생성할 때 사용하면 성능이 더 좋다.
        - 예시: age라는 하나의 필드로 쿼리를 보낼 때
    - 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스이다.
        - 예시: age, name, email 등 여러 필드 기반으로 쿼리를 보낼 때

### MongoDB

- 기본 인덱스
    - 도큐먼트를 만들면 자동으로 ObjectID가 생성되는데, 이 키가 기본키로 설정된다.
- 복합 인덱스
    - 세컨더리 키도 부가적으로 설정하면 기본키와 세컨더리 키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

## 인덱스 최적화 기법

- 최적화 기법은 데이터베이스마다 다를 수 있다.
- 여기서는 MongoDB를 기반으로 최적화 기법을 설명하고, 이를 기반으로 다른 데이터베이스에 어느정도 보편적으로 적용 가능하다.

### MongoDB 최적화 기법의 특징 3가지

1. 인덱스는 무조건 다 사용하는 것이 아니다.
    - 인덱스는 두 번 탐색하도록 강요한다.
        - 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 들게 된다.
    - 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
        - 이때 B-트리 높이를 균형 있게 조절하는 비용도 든다.
        - 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.
    - 따라서 쿼리에 있는 필드에 인덱스를 무작정 설정하는 것은 답이 아니다.
        - 특히 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.

 2. 항상 테스팅하며 시간을 최소화한다.
    - 인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양이 다르기 때문이다.
    - 따라서 테스팅을 항상 하는 것이 중요하다.
    - explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.

3. 복합 인덱스의 경우 같음, 정렬, 다중값, **카디널리티** 순으로 생성한다.
    - 복합 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스의 성능이 달라진다.
    - 같음, 정렬, 다중값, 카디널리티 순으로 생성해야 한다.
        1. 어떠한 값과 같음을 비교하는 == 이나 equal 쿼리가 있으면 제일 먼저 인덱스로 설정한다.
        2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정
        3. 다중 값을 출력해야 하는 필드, 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드면 그 다음 인덱스로 설정한다.
        4. 그 다음에는 카디널리티가 높은 순서를 고려해서 인덱스를 생성해야 한다. 예를 들어, age와 email이 있다면 email이 카디널리티가 높으므로 email 필드에 대한 인덱스를 age보다 먼저 설정해야 한다.
    > - **카디널리티**: 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다. 카디널리티가 높다는 말은 중복도가 낮다는 말로, 상대적인 개념으로 이해한다.

---

## **참고 자료**

- 관련 서적
    - [면접을 위한 CS 전공지식 노트(주홍철)](https://product.kyobobook.co.kr/detail/S000001834833?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=aud-901091942354:dsa-435935280379&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1&gclid=Cj0KCQjwwYSwBhDcARIsAOyL0fhby9LTtW8HLZ5Wg0aW9oKf_EyHPNtAttNCtkeyvmU4HlWw4sGx6VYaAnT5EALw_wcB)
- 블로그
    - [[database] 카디널리티(cardinality)란?](https://itholic.github.io/database-cardinality/)
- 이미지 출처
    - [B-트리 예제 1,2](https://hapen385.tistory.com/66)
    - [클러스터형 인덱스, 세컨더리 인덱스](https://rachel0115.tistory.com/entry/MySQL-%EC%9D%B8%EB%8D%B1%EC%8A%A4-INDEX-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-%EC%83%9D%EC%84%B1-%EC%82%AD%EC%A0%9C-%EC%84%A4%EA%B3%84)